# Rate limiter

**Алгоритм:** Sliding log

**Команда:** Шепелев Алекей, Старостин Иван, Пелько Андрей

### Доказательство корректности

**Что собираемся доказывать:** на любом интервале времени длинной `intervalNanos`,
происходит не более `maxExecutions` вызовов целевого сервиса.

Для этого будем хранить сет временных меток вызовов целевого сервиса. 
При получении нового запроса в момент вермени `t0` происходит проверка количества 
вызовов на интервале `[t0 - intervalNanos, t0 + intervalNanos]`. Выполнение данного 
условия достаточно для соблюдения гарантий алгоритма.

Сначала проверка производится по принципу Test and TestAndSet, то есть
сначала конкурентная, затем блокирующая с присваиванием.

### Технические особенности

Во избежании переполнения лога запросов после выполнения запроса происходит
очистка "старых" (вызванных ранее момента `t0 - timeoutNanos`) запросов.
Где `timeoutNanos` – промежуток времени, по истечении которого запросы можно
считать неактуальными.

Также чтобы не выполнять "старые" запросы, происходит проверка их актуальности:
`t0 > currentTime() - timeoutNanos`.

### Архитектура
[Архитектура распределенного Rate Limiter](DistributedArchitecture.md)
